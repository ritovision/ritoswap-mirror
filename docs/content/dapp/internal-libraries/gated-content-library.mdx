---
title: "Gated Content"
description: "Internal library that assembles and delivers the exclusive content package for authenticated token gate users"
---

import { FileTree, Table, Tabs, Callout, Steps } from 'nextra/components'

# Gated Content Library

The Gated Content Library serves as the content management system for RitoSwap's token gate, assembling all the exclusive content that authenticated users receive. This internal library combines HTML, CSS, JavaScript, and audio data into a cohesive package that creates an immersive experience for token holders.

## Overview

When users successfully unlock the token gate with their Colored Key NFT, they gain access to exclusive content that includes the ability to submit a single message and listen to secret crypto-themed music. The Gated Content Library orchestrates this experience by packaging all necessary components into a structured format that the frontend can render seamlessly.

### The Token Gate Experience

The gated content represents the culmination of the user's journey through RitoSwap's token system. After minting or acquiring a Colored Key NFT and proving ownership through wallet signatures, users are rewarded with access to this exclusive area. The content is designed to be ephemeral—users can submit only one message with their key before it's marked as used, making each interaction unique and valuable.

<FileTree>
  <FileTree.Folder name="lib" defaultOpen>
    <FileTree.Folder name="server" defaultOpen>
      <FileTree.File name="gatedContent.ts" />
    </FileTree.Folder>
  </FileTree.Folder>
</FileTree>

## Content Structure

The `getGatedContent` function returns a comprehensive content package:

```typescript
export async function getGatedContent() {
  return {
    welcomeText: string,          // Welcome message for authenticated users
    textSubmissionAreaHtml: string, // HTML for the message submission form
    audioData: {                  // Audio player configuration
      headline: string,
      imageSrc: string,
      imageAlt: string,
      description: string,
      title: string,
      audioSrc: string,          // Signed URL from R2
      error?: boolean
    },
    styles: string,              // CSS for styling the content
    script: string               // JavaScript for form interaction
  };
}
```

### Content Components Breakdown

The library assembles four main components that work together to create the gated experience:

#### 1. Welcome Text
The introductory message sets expectations for users entering the exclusive area. It explains the one-time message submission rule and teases the exclusive audio content, creating anticipation and emphasizing the limited nature of the experience.

#### 2. Text Submission Area
A carefully crafted HTML form allows users to submit their single message. The form includes a textarea for message input and a submit button that triggers the signature and submission process. The HTML is designed to be injected safely into the page with proper styling hooks.

#### 3. Audio Data
Configuration for the AudioWrapper component, including metadata about the exclusive track and the signed URL generated by the R2 library. This creates the music player interface that showcases Rito Rhymes' crypto-themed parody music.

#### 4. Styling and Scripts
Custom CSS creates the cyberpunk aesthetic with glowing borders and animations, while the JavaScript handles form submission logic and connects to the parent component's submission handler.

## API Reference

| Function | Signature | Returns | Notes |
|----------|-----------|---------|-------|
| **getGatedContent** | `(): Promise<GatedContentResponse>` | Complete content package | Assembles all gated content including signed audio URL |

### Response Type Structure

```typescript
interface GatedContentResponse {
  welcomeText: string
  textSubmissionAreaHtml: string
  audioData: AudioData
  styles: string
  script: string
  audioError?: boolean
  errorMessage?: string
}

interface AudioData {
  headline: string       // "Secret Crypto Music"
  imageSrc: string      // Album cover path
  imageAlt: string      // Accessibility text
  description: string   // Track description
  title: string         // "Hit Me Bitcoin One More Time"
  audioSrc: string      // Signed R2 URL
  error?: boolean       // Audio availability flag
}
```

## Implementation Details

### Audio URL Generation

The library integrates with the R2 storage system to provide secure audio access:

```typescript
let audioUrl: string;
let audioError = false;

try {
  audioUrl = await generateSignedAudioUrl();
} catch (error) {
  console.error('Failed to generate signed audio URL:', error);
  audioUrl = '';
  audioError = true;
}
```

This error handling ensures that audio failures don't break the entire gated experience—users can still submit their message even if the audio is temporarily unavailable.

### HTML Content Structure

The text submission area HTML is carefully structured for security and functionality:

```html
<div class="textSubmissionContainer">
  <h2 class="textSubmissionTitle">Submit Your Message</h2>
  <form id="gatedSubmissionForm" class="textSubmissionForm">
    <textarea
      id="gatedTextarea"
      class="textSubmissionTextarea"
      placeholder="Enter your message here..."
      rows="6"
    ></textarea>
    <button
      type="submit"
      id="gatedSubmitButton"
      class="textSubmissionButton"
    >
      Sign & Submit
    </button>
  </form>
</div>
```

Each element has specific IDs and classes that connect to both the styling system and the JavaScript behavior handlers.

### Styling System

The CSS creates a cohesive visual experience with the Blade Runner-inspired aesthetic:

```css
.textSubmissionContainer {
  background: rgba(0, 30, 60, 0.8);
  border: var(--default-border);
  box-shadow: 
    0 0 20px rgba(0, 123, 255, 0.3),
    0 0 40px rgba(0, 123, 255, 0.2),
    0 0 60px rgba(0, 123, 255, 0.1),
    inset 0 0 20px rgba(0, 123, 255, 0.1);
  animation: glowPulse 3s ease-in-out infinite;
}
```

The glowing animation and layered shadows create depth and visual interest, making the exclusive content feel special and otherworldly.

### JavaScript Behavior

The embedded script handles form submission with proper validation and error handling:

```javascript
form.addEventListener('submit', async (e) => {
  e.preventDefault();
  
  const text = textarea.value.trim();
  if (!text) {
    alert('Please enter some text');
    return;
  }
  
  // Disable button and show processing state
  submitButton.disabled = true;
  submitButton.textContent = 'Sending...';
  submitButton.classList.add('processing');
  
  try {
    window.handleGatedSubmission(text);
  } catch (error) {
    // Re-enable on error
    submitButton.disabled = false;
    submitButton.textContent = 'Sign & Submit';
    submitButton.classList.remove('processing');
  }
});
```

The script connects to the parent component through the global `handleGatedSubmission` function, which is injected by the GatedContentRenderer.

## Integration Flow

The gated content flows through several components in the RitoSwap system:

<Steps>
### Step 1: User Unlocks Gate
The GateModal component verifies ownership and signatures, then calls the `/api/gate-access` endpoint.

### Step 2: API Fetches Content
The gate-access API calls `getGatedContent()` to assemble the content package, including generating the signed audio URL.

### Step 3: Content Delivery
The content is passed back through the GateModal to the GatePageWrapper via the `onContentReceived` callback.

### Step 4: Rendering
The GatedContentRenderer component receives the content and renders it, injecting styles, HTML, and executing the script.

### Step 5: User Interaction
Users can play the exclusive audio and submit their one-time message, which triggers the signature and submission flow.
</Steps>

### Component Integration Example

The current renderer uses a tabbed layout (message, music, chatbot), injects styles, and exposes helpers on `window`:

```typescript
// app/gate/components/GatedContentRenderer/GatedContentRenderer.tsx (trimmed)
useEffect(() => {
  const styleId = 'gated-content-styles';
  let styleEl = document.getElementById(styleId) as HTMLStyleElement | null;
  if (!styleEl) {
    styleEl = document.createElement('style');
    styleEl.id = styleId;
    document.head.appendChild(styleEl);
  }
  styleEl.textContent = content.styles;
}, [content.styles]);

useEffect(() => {
  (window as GateWindow).__gate = {
    buildEnvelope: buildAndStashEnvelope,
    buildBoundMessage: buildBoundMessageCompat,
  };
  (window as GateWindow).handleGatedSubmission = async (input) => {
    const message = typeof input === 'string' ? input : input?.message ?? '';
    return onSubmit(message);
  };
  return () => {
    delete (window as GateWindow).handleGatedSubmission;
    delete (window as GateWindow).__gate;
  };
}, [onSubmit]);

const initializeForm = () => {
  messageFormRef.current!.innerHTML = content.textSubmissionAreaHtml;
  if (!scriptExecutedRef.current) {
    new Function(content.script)();
    scriptExecutedRef.current = true;
  }
};

return (
  <TabsContainer
    messageContent={<MessageFormContent ... onMount={initializeForm} />}
    musicContent={<AudioWrapper {...content.audioData} />}
    chatbotContent={<ChatBot />}
  />
);
```

## Security Considerations

### Content Injection Safety

While the library returns HTML and JavaScript as strings, several measures ensure security:

1. **Trusted Source**: Content comes from server-side code, not user input
2. **Scoped Execution**: JavaScript runs in a controlled context
3. **No User Data**: The HTML template doesn't include any user-provided content
4. **Event Validation**: Form submission is validated before processing

### Message Submission Security

The submission flow includes multiple security layers:

```typescript
// In GatePageWrapper handleGatedSubmission
const signMessage = `Token Gate Access Request:
Token ID: ${tokenId}
Address: ${address}
Timestamp: ${timestamp}
Message: ${text}`;

const signature = await signMessageAsync({ message: signMessage });
```

This creates a tamper-proof record of:
- Which token was used
- Who submitted the message
- When it was submitted
- The exact message content

## Customization Points

### Modifying the Welcome Message

Edit the `welcomeText` string in `dapp/app/lib/server/gatedContent.ts` to reflect different campaigns or events.

### Styling Variations

The CSS can be modified for special themes:

```typescript
const seasonalStyles = {
  default: defaultStyles,
  halloween: halloweenStyles,
  holiday: holidayStyles
};

styles: seasonalStyles[currentSeason] || seasonalStyles.default
```

### Dynamic Audio Selection

The audio data could be randomized or based on token attributes:

```typescript
const tracks = [
  { title: "Hit Me Bitcoin One More Time", file: "HitMeBitcoin.mp3" },
  { title: "Crypto Killed The Radio Star", file: "CryptoKilled.mp3" },
  { title: "Sweet Chain O' Mine", file: "SweetChain.mp3" }
];

const selectedTrack = tracks[tokenId % tracks.length];
```

## Error Handling

The library implements graceful degradation for various failure scenarios:

### API fallback when content generation fails

If `getGatedContent` throws inside `/api/gate-access`, the route responds with a minimal HTML snippet and an audio error flag instead of failing the request. Authenticated users can still reach the gate even when R2 or content assembly is down.

### Audio Failure Handling

When R2 storage is unavailable:
```typescript
if (content.audioData.error || audioError) {
  return (
    <div className={styles.audioError}>
      <h3>Audio Temporarily Unavailable</h3>
      <p>Please refresh the page to try again</p>
    </div>
  );
}
```

### Script Execution Errors

The renderer wraps script execution in try-catch:
```typescript
try {
  const runner = new Function(content.script);
  runner();
} catch (error) {
  console.error("Error executing gated content script:", error);
}
```

### Submission Failures

The embedded script handles submission errors:
```typescript
catch (error) {
  console.error('Submission error:', error);
  alert('Failed to submit. Please try again.');
  // Re-enable form for retry
}
```

## Testing Considerations

When testing the gated content system:

### Content Assembly Testing
```typescript
describe('getGatedContent', () => {
  it('returns complete content structure', async () => {
    const content = await getGatedContent();
    
    expect(content).toHaveProperty('welcomeText');
    expect(content).toHaveProperty('textSubmissionAreaHtml');
    expect(content).toHaveProperty('audioData');
    expect(content).toHaveProperty('styles');
    expect(content).toHaveProperty('script');
  });
  
  it('handles audio URL generation failure', async () => {
    // Mock R2 failure
    vi.mocked(generateSignedAudioUrl).mockRejectedValue(new Error('R2 error'));
    
    const content = await getGatedContent();
    expect(content.audioData.error).toBe(true);
    expect(content.audioData.audioSrc).toBe('');
  });
});
```

### Integration Testing
Test the full flow from gate unlock to content rendering:
- Verify style injection doesn't conflict with existing styles
- Ensure script execution doesn't throw errors
- Test form submission connection to parent handler
- Validate audio player initialization

## Performance Optimization

### Content Caching Strategy

Since the content structure rarely changes, consider caching:

```typescript
let cachedContent: GatedContentResponse | null = null;
let cacheExpiry: number = 0;

export async function getGatedContent() {
  if (cachedContent && Date.now() < cacheExpiry) {
    // Only regenerate audio URL
    cachedContent.audioData.audioSrc = await generateSignedAudioUrl();
    return cachedContent;
  }
  
  // Generate fresh content
  const content = await generateFreshContent();
  cachedContent = content;
  cacheExpiry = Date.now() + (5 * 60 * 1000); // 5 min cache
  
  return content;
}
```

### Lazy Loading Assets

The audio and images can be lazy-loaded:
```typescript
audioData: {
  // ...other fields
  lazyLoad: true,
  preload: 'metadata' // Only load metadata initially
}
```

## Summary

The Gated Content Library serves as the heart of RitoSwap's exclusive content system, orchestrating a carefully crafted experience for token holders. By combining secure audio delivery, interactive message submission, and immersive styling, it creates a memorable moment that justifies the effort users put into obtaining and using their Colored Key NFTs. The library's modular design, comprehensive error handling, and security considerations ensure that this exclusive content remains both special and reliable for every user who earns access to it.
